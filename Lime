import xgboost as xgb

# Assuming you have trained your XGBoost model and loaded your dataset 'data' and 'target'
# Train your XGBoost model
xgb_model = xgb.XGBClassifier()
xgb_model.fit(data, target)

# Extract the decision paths for each class
decision_paths = []
for class_idx, class_name in enumerate(xgb_model.classes_):
    class_decision_path = []
    for tree in xgb_model.get_booster().get_dump():
        tree_dict = eval(tree)  # Convert the tree string to a dictionary
        tree_path = []
        node_stack = [tree_dict]
        while node_stack:
            node = node_stack.pop()
            if 'children' in node:
                split_feature = node['split']
                split_value = node['split_condition']
                tree_path.append(f"{split_feature} > {split_value}" if node['yes'] == class_idx else f"{split_feature} <= {split_value}")
                node_stack.append(tree_dict[int(node['yes'])])  # Right child
                node_stack.append(tree_dict[int(node['no'])])  # Left child
            else:
                leaf_value = node['leaf']
                if leaf_value == 'nan':
                    leaf_value = 0  # Handling missing leaf value
                tree_path.append(f"Class {class_idx}: {float(leaf_value)}")
                break
        class_decision_path.append(tree_path)
    decision_paths.append((class_name, class_decision_path))

# Print the decision paths for each class
for class_name, class_decision_path in decision_paths:
    print(f"{class_name}")
    for tree_path in class_decision_path:
        print(" -> ".join(tree_path))
    print()
# JSONDecodeError: Extra data: line 1 column 2 (char 1)

